@model IEnumerable<ChatApp.Models.ChatMessage>
@{
    ViewData["Title"] = "Chat Room";
    var currentRoom = ViewBag.Room as string ?? "general";
}

<div class="row">
    <div class="col-md-9">
        <div class="card">
            <div class="card-header d-flex justify-content-between align-items-center">
                <h5 class="mb-0">Chat Room: @currentRoom.ToUpper()</h5>
                <span id="connectionStatus" class="badge bg-secondary">Connecting...</span>
            </div>
            <div class="card-body">
                <div id="messagesList" class="chat-container">
                    @{
                        var fullName = User.FindFirst("FirstName")?.Value + " " + User.FindFirst("LastName")?.Value;
                    }

                    @foreach (var message in Model)
                    {
                        var isOwnMessage = message.SenderName == fullName;
                        <div class="message @(isOwnMessage ? "own" : "other")">
                            <div class="message-header">
                                <strong>@message.SenderName</strong> - @message.Timestamp.ToString("HH:mm")
                            </div>
                            <div>@message.Message</div>
                        </div>
                    }
                </div>

                <div class="input-group">
                    <input type="text" id="messageInput" class="form-control" placeholder="Type your message..." maxlength="1000" />
                    <button class="btn btn-primary" type="button" id="sendButton">Send</button>
                </div>
            </div>
        </div>
    </div>

    <div class="col-md-3">
        <div class="card">
            <div class="card-header">
                <h6 class="mb-0">Online Users</h6>
            </div>
            <div class="card-body">
                <div id="usersList" class="online-users">
                    <div class="text-muted">Loading users...</div>
                </div>
            </div>
        </div>
    </div>
</div>

@section Scripts {
    <script>
        "use strict";

        let connection;
        let currentUser = '@User?.Identity?.Name';
        let currentUserFullName = '@(User?.FindFirst("FirstName")?.Value + " " + User?.FindFirst("LastName")?.Value)';
        loadOnlineUsers();
        setInterval(loadOnlineUsers, 5000);

        // Get JWT token from cookie
        async function getToken() {
            try {
                const response = await fetch('/Chat/GetToken');
                console.log(response);
                const data = await response.json();
                return data.token;
            } catch (error) {
                console.error('Error getting token:', error);
                return null;
            }
        }

        // Initialize SignalR connection
        async function initializeConnection() {
            const token = await getToken();

            if (!token) {
                console.error('No token available');
                document.getElementById('connectionStatus').textContent = 'Authentication Error';
                document.getElementById('connectionStatus').className = 'badge bg-danger';
                return;
            }

            connection = new signalR.HubConnectionBuilder()
                .withUrl("/chatHub", {
                    accessTokenFactory: () => token
                })
                .build();

            // Handle incoming messages
            connection.on("ReceiveMessage", function (sender, message, time) {
                addMessageToChat(sender, message, time, sender === currentUserFullName);
            });

            // Handle user joined
            connection.on("UserJoined", function (userName, user) {
                if (user !== currentUser) {
                    addSystemMessage(userName + " joined the chat");
                }
            });

            // Handle user left
            connection.on("UserLeft", function (userName, user) {
                if (user !== currentUser) {
                    addSystemMessage(userName + " left the chat");
                }
            });

            // Start connection
            try {
                await connection.start();
                document.getElementById('connectionStatus').textContent = 'Connected';
                document.getElementById('connectionStatus').className = 'badge bg-success';

                // Join the room
                // await connection.invoke("JoinRoom", "@ViewBag.Room");

            } catch (err) {
                console.error('SignalR Connection Error: ', err);
                document.getElementById('connectionStatus').textContent = 'Connection Failed';
                document.getElementById('connectionStatus').className = 'badge bg-danger';
            }
        }

        // Add message to chat
        function addMessageToChat(sender, message, time, isOwnMessage) {
            const messagesList = document.getElementById("messagesList");
            const messageDiv = document.createElement("div");
            messageDiv.className = `message ${isOwnMessage ? 'own' : 'other'}`;

            messageDiv.innerHTML = `
                        <div class="message-header">
                            <strong>${sender}</strong> - ${time}
                        </div>
                        <div>${escapeHtml(message)}</div>
                    `;

            messagesList.appendChild(messageDiv);
            messagesList.scrollTop = messagesList.scrollHeight;
        }

        // Add system message
        function addSystemMessage(message) {
            const messagesList = document.getElementById("messagesList");
            const messageDiv = document.createElement("div");
            messageDiv.className = "text-center text-muted small mb-2";
            messageDiv.textContent = message;

            messagesList.appendChild(messageDiv);
            messagesList.scrollTop = messagesList.scrollHeight;
        }

        // Escape HTML to prevent XSS
        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Send message
        async function sendMessage() {
            const messageInput = document.getElementById("messageInput");
            const message = messageInput.value.trim();

            if (message && connection) {
                try {
                    await connection.invoke("SendMessage", message, "@ViewBag.Room");
                    messageInput.value = "";
                } catch (err) {
                    console.error('Send Message Error: ', err);
                    alert('Failed to send message. Please try again.');
                }
            }
        }

        // Event listeners
        document.getElementById("sendButton").addEventListener("click", sendMessage);

        document.getElementById("messageInput").addEventListener("keypress", function (e) {
            if (e.key === "Enter") {
                sendMessage();
            }
        });

        // Initialize connection when page loads
        document.addEventListener("DOMContentLoaded", function () {
            initializeConnection();
        });

        // Handle page unload
        window.addEventListener("beforeunload", function () {
            if (connection) {
                connection.stop();
            }
        });

        async function loadOnlineUsers() {
            try {
                const response = await fetch('/Chat/GetOnlineUsers');
                const users = await response.json();

                const usersList = document.getElementById("usersList");
                usersList.innerHTML = "";

                if (users.length === 0) {
                    usersList.innerHTML = "<div class='text-muted'>No users available.</div>";
                    return;
                }

                // Sort: current user first, then by online status
                users.sort((a, b) => {
                    if (a.userName === currentUser) return -1;
                    if (b.userName === currentUser) return 1;
                    if (a.isOnline && !b.isOnline) return -1;
                    if (!a.isOnline && b.isOnline) return 1;
                    return 0;
                });

                users.forEach(user => {
                    const div = document.createElement("div");

                    const isCurrentUser = user.userName === currentUser;
                    const isOnline = user.isOnline;

                    // Set class based on online status
                    div.className = isOnline ? "user-item" : "user-item offline";

                    const dotClass = isOnline ? "text-success" : "text-muted";
                    const dot = `<span class="${dotClass} me-1">●</span>`;
                    const name = isCurrentUser
                        ? `<strong>You (${user.firstName} ${user.lastName})</strong>`
                        : `${user.firstName} ${user.lastName}`;

                    const status = isOnline
                        ? "<span class='text-success ms-2'>Online</span>"
                        : `<div class='text-muted ms-4'>Last seen: ${formatDateTime(user.lastSeen)}</div>`;

                    div.innerHTML = `${dot} ${name}<br>${status}`;
                    usersList.appendChild(div);
                });
            } catch (err) {
                console.error("Failed to load users", err);
            }
        }

        // Format lastSeen datetime
        function formatDateTime(dateTimeStr) {
            const date = new Date(dateTimeStr);
            const now = new Date();

            const oneDay = 24 * 60 * 60 * 1000;
            const diffTime = now - date;
            const diffDays = Math.floor(diffTime / oneDay);

            const isToday = date.toDateString() === now.toDateString();

            const yesterday = new Date();
            yesterday.setDate(now.getDate() - 1);
            const isYesterday = date.toDateString() === yesterday.toDateString();

            if (isToday) {
                return date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' });
            } else if (isYesterday) {
                return "Yesterday";
            } else if (diffDays < 7) {
                return date.toLocaleDateString(undefined, { weekday: 'long' });
            } else {
                return `${date.toLocaleDateString(undefined, { month: 'short', day: 'numeric' })}, ${date.toLocaleTimeString([], { hour: 'numeric', minute: '2-digit' })}`;
            }
        }

    </script>
}